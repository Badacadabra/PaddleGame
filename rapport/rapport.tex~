\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel} 
\usepackage{listings}
\usepackage{textcomp}
\usepackage{color}
\usepackage{graphicx}
\usepackage{pdflscape}
\usepackage[colorlinks=false, urlcolor=black, breaklinks, pagebackref, citebordercolor={0 0 0}, filebordercolor={0 0 0}, linkbordercolor={0 0 0}, pagebordercolor={0 0 0}, runbordercolor={0 0 0}, urlbordercolor={0 0 0}, pdfborder={0 0 0}]{hyperref}

\lstset {
language=php,
upquote=true,
columns=flexible,
stringstyle=\ttfamily,
aboveskip=\topsep,
belowskip=\topsep,
breaklines,
breakindent=1.2em,
showstringspaces=false,
numbers=none,
frameshape={RYRYNYYYY}{yny}{yny}{RYRYNYYYY}
%frame=shadowbox,
%rulesepcolor=\color{black}
}

\setlength{\parskip}{10pt}

\title{\textbf{UMDN3E - Java - Paddle Game}}
\author{\textsc{Macky Dieng \& Baptiste Vannesson}}
\date{\textit{\today}}

\begin{document}

\begin{figure}
 \begin{center}
  \includegraphics[scale=.3]{unicaen.png}
 \end{center}
\end{figure}

\maketitle

\begin{figure}[!h]
 \begin{center}
  \includegraphics[scale=.3]{paddle-game.png}
 \end{center}
\end{figure}

\tableofcontents
\newpage

\section{Quelques précisions}

Ce projet a été développé sous Eclipse avec une architecture «~maison~». Les tâches de compilation, de distribution et de génération de la Javadoc ont été réalisées avec Ant par le biais d'un build.xml. Ce projet contient en réalité deux sous-projets (le client et le serveur) avec la structure suivante :

\begin{figure}[h]
 \begin{center}
  \includegraphics[scale=.5]{dossiers.png}
 \end{center}
 \caption{Structure du projet}
\end{figure}

\vspace{7pt}

\begin{itemize}
 \item{« build » : contient les fichiers compilés (*.class).}
 \item{« dist » : contient le jar exécutable (cf. « java -jar *.jar »).}
 \item{« doc » : contient la Javadoc pour l'ensemble du code (cf. index.html).}
 \item{« src » : contient les sources d'un sous-projet, organisées en 2 packages.}
\end{itemize}

\vspace{7pt}

\textbf{
  À noter qu'il s'agit ici d'un projet réalisé en binôme. Pour ce devoir, la répartition était assez naturelle :
  \vspace{7pt}
  \begin{itemize}
    \item{Client : Baptiste}
    \item{Serveur : Macky}
  \end{itemize}
\end{textbf}
}

\vspace{10pt}

Bien évidemment, la phase de conception (UML et création du protocole) a été réalisée à deux pour que chacun ait une vision globale du fonctionnement de l'application. Les diagrammes, de classes et de séquence, résultent donc d'un travail collectif. Pour le reste, tout ce qui a trait au \textbf{client} est à attribuer à \textbf{Baptiste}, et tout ce qui a trait au \textbf{serveur} est à attribuer à \textbf{Macky}. Ceci est valable pour les sections de ce rapport, mais aussi dans le code. Chaque classe indique son auteur dans la Javadoc. Naturellement, le protocole est une partie commune car c'est ce qui fait le lien entre le client et le serveur.

\textit{Le code étant largement documenté, ce rapport se contentera d'apporter un éclairage sur les points importants de la conception et du développement.}

\newpage

\section{Détails sur la conception}

\textbf{Attention} : les constructeurs, les accesseurs et les mutateurs n'apparaissent pas, volontairement, dans les diagrammes UML à des fins de simplification. Ils n'apporteraient pas grand-chose dans la représentation du problème et ne feraient qu'alourdir inutilement les diagrammes.

\subsection{Client}

Côté client, en dépit de l'aspect minimaliste du jeu, il y a un grand nombre de classes qui interviennent pour faire fonctionner l'application. Commençons d'abord par évoquer les éléments d'interface, c'est-à-dire la vue. Nous parlerons ensuite du projet sous un angle plus technique, en insistant notamment sur le multithreading.

L'affichage repose en premier lieu sur une JFrame qui nous sert ici de top-level container. Cette fenêtre est composée de deux panneaux, dont un JScrollPane (ScoresZone) qui contient une JList (ScoresList) pour l'affichage des scores, et un JPanel (GameZone) qui sert en quelque sorte d'ardoise pour dessiner les différents composants du jeu, en l'occurrence la balle et les raquettes (cf. paintComponent). Le principe ici est de faire un repaint() dès lors qu'une action se produit ; par exemple lorsque la balle bouge ou lorsque l'utilisateur déplace sa raquette. Dans le cas présent, d'après les principes du pattern \textbf{Observer}, c'est la zone de jeu (GameZone) qui écoute les déplacements de la raquette via un MouseMotionListener.

On remarquera que les scores, et donc la JList (vue), s'appuient sur un modèle de liste ; en particulier un DefaultListModel. Il s'agit là d'une implémentation à échelle réduite du pattern \textbf{MVC} car, dans le cadre du jeu, nous pouvons facilement manipuler le modèle de liste (pour ajouter, modifier, supprimer des éléments) et en informer implicitement la vue ; toujours selon les principes du pattern \textbf{Observer}. En d'autres termes, à chaque fois que le modèle de liste est mis à jour, la JList se met à jour également et affiche l'état courant du modèle. D'un autre côté, notre JList étendue implémente indirectement l'interface ListCellRendering, ceci afin de personnaliser l'affichage (ce qui s'avère notamment utile pour affecter une couleur spécifique à chaque label de la liste...).

On remarquera aussi l'utilisation du pattern \textbf{Singleton} pour s'assurer de ne manipuler qu'une seule instance de Ball. En effet, on part du principe que le jeu ne doit contenir qu'une seule balle. Il vaut donc mieux passer par une factory method statique (getBall) qui va s'assurer de l'inexistence de l'instance avant d'en créer une nouvelle, plutôt que par un constructeur public qui va recréer systématiquement une nouvelle instance. On sait d'ailleurs que les coordonnées de la balle sont fournies au client par le serveur, ce qui sous-entend des opérations fréquentes sur l'objet balle (dans des boucles infinies...). Le Singleton apporte ici une sécurité importante car un «~new~» dans une boucle infinie peut réellement avoir des effets inattendus !

Concernant maintenant le multithreading, on peut voir sur le diagramme UML du client qu'il y a 4 threads utilisés pour faire tourner l'application. Le premier thread est ClientGUI lui-même. Ce dernier se charge de récupérer les entrées/sorties pour interagir avec le serveur et de lancer deux threads qui vont s'occuper réellement de la communication. Le thread Input va gérer en continu tous les messages qui arrivent en entrée, c'est-à-dire tout ce qui vient du serveur, tandis que le thread Output va gérer en continu les messages à envoyer au serveur. En quelque sorte, ces deux derniers threads permettent une communication bidirectionnelle selon un protocole que nous verrons plus loin dans ce rapport.

On peut voir que les classes Input et Output héritent toutes les deux d'une classe abstraite IO. Cette classe abstraite est ici à des fins de factorisation, pour éviter la redondance de code. On sait en effet que les entrées/sorties dépendent directement de la zone de jeu. Par exemple, on met bien à jour la position de la balle dans la zone de jeu avec les données qui viennent du serveur (Input), et on envoie bien au serveur la nouvelle position de la raquette dans la zone de jeu (Ouput).

À noter enfin la présence d'un quatrième thread gérant exclusivement la zone de jeu, celle-ci étant amenée à évoluer en temps réel en fonction des données provenant du serveur.

\begin{landscape}
  \begin{figure}
  \begin{center}
    \includegraphics[scale=.4]{diagramme-client.png}
  \end{center}
  \caption{Diagramme de classes (UML) du client}
  \end{figure}
\end{landscape}

\subsection{Serveur}

Lorem ipsum dolor sit amet...

\begin{landscape}
  \begin{figure}
  \begin{center}
    \includegraphics[scale=.4]{diagramme-serveur.png}
  \end{center}
  \caption{Diagramme de classes (UML) du serveur}
  \end{figure}
\end{landscape}

\subsection{Protocole}

Nous devions ici développer une application réseau de type client-serveur. Avant de commencer le développement, il était donc essentiel de concevoir le protocole, c'est-à-dire les règles de communication entre les deux acteurs de l'application.

Pour concevoir ce protocole, il fallait d'abord réfléchir aux données qui devaient être envoyées de part et d'autre...

\textbf{Le client doit envoyer au serveur :}
\begin{itemize}
 \item{Son pseudo}
 \item{La position de sa raquette}
\end{itemize}

\vspace{7pt}

\textbf{Le serveur doit envoyer au client :}
\begin{itemize}
 \item{Les informations sur tous les joueurs (pseudonymes, scores, positions des raquettes)}
 \item{La position de la balle}
\end{itemize}

\vspace{7pt}

En partant de ce constat, on peut ici définir quatre primitives pour régir la relation entre le client et le serveur :

\begin{itemize}
 \item{SEND\_PSEUDO}
 \item{SEND\_PADDLE\_POSITION}
 \item{SEND\_GAMERS\_INFO}
 \item{SEND\_BALL\_COORDS}
\end{itemize}

Ainsi, lorsque le client enverra la primitive SEND\_PSEUDO, le serveur comprendra que les données qui suivent contiennent le pseudo du joueur. De même, lorsque le serveur enverra la primitive SEND\_BALL\_COORDS, le client comprendra que le serveur lui envoie la nouvelle position de la balle. La communication entre le client et le serveur est désormais possible.

\newpage

Architecture en étoile...

\newpage

\begin{figure}[!h]
  \begin{center}
    \includegraphics[scale=.4]{protocole.png}
  \end{center}
  \caption{Diagramme de séquence du protocole de communication}
\end{figure}

\section{Détails sur le développement}

\subsection{Client}

Côté client, le projet est organisé en deux packages. À vrai dire, ce ne sont pas de vrais packages au sens strict du terme, car les deux sont intimement liés pour faire fonctionner le jeu. Il était cependant plus clair de séparer la partie purement «~jeu~» de la partie réseau qui gère toutes les interactions avec le serveur.

Dans le package «~game~», on trouve toutes les classes gérant l'interface graphique, ainsi que les éléments du jeu tels que la balle (Ball) ou encore la raquette (Paddle). Concernant l'interface graphique proprement dite, il a fallu étendre les classes de base fournies par Java (JList, JScrollPane, JPanel, ...) pour pouvoir configurer ces composants avec plus de souplesse. Dans la plupart des classes héritées de composants simples Swing, comme par exemple ScoresList ou ScoresZone, on trouve majoritairement un arsenal de constantes et de mutateurs dans le constructeur pour définir les préférences graphiques.

Ceci n'est pas systématique, et on peut le voir notamment avec GameZone où tout s'articule autour de la méthode paintComponent dont la structure a été inspirée du pattern \textbf{Template}. Au sein de cette méthode, on retrouve en effet principalement des appels à d'autres méthodes (en l'occurrence privées), et ces appels définissent la séquence d'exécution du dessin. Ici la séquence a tout de même son importance car il convient de dessiner la zone de jeu avant les autres composants (balle et raquettes). Mais plus généralement, ce découpage au sein de paintComponent rend la méthode beaucoup plus lisible, ce qui permet de mieux visualiser dans le code ce qui est dessiné et dans quel ordre.

Par ailleurs, le jeu utilise un certain nombre d'entités qui se traduisent dans le code par des JavaBeans (sans sérialisation), c'est-à-dire des composants simples réutilisables. On peut citer notamment la classe Ball, la classe Paddle, ou encore la classe Gamer, qui sont toutes des classes représentant des entités manipulables. Ces classes définissent toutes un constructeur par défaut sans paramètres et elles respectent toutes le principe d'encapsulation, fournissant de fait des moyens d'accès en lecture et en écriture aux attributs (via des getters et des setters).

\subsection{Serveur}

Lorem ipsum dolor sit amet...

\subsection{Protocole}

Du point de vue du code, le protocole a d'abord été implémenté en utilisant des constantes (avec énumération côté client et simple classe côté serveur). Ces constantes correspondent en fait aux primitives évoquées plus haut.

Concrètement, le développement du protocole se trouve dans le package network/communication, que ce soit côté client ou côté serveur. Il est notamment utilisé dans les threads gérant les entrées/sorties (Input/Reception \& Output/Emission). Dans ces threads, des tests sont réalisés en continu dans une boucle infinie pour connaître la primitive transmise. Ces tests permettent notamment d'effectuer des actions spécifiques en fonction de la primitive.

Le protocole s'appuie surtout sur des classes fournies par Java, à savoir un BufferedReader pour les entrées (in) et un PrintWriter pour les sorties (out). Le client et le serveur ne s'échangent donc des informations qu'au travers de simples out.println() et in.readline(). Toutes les données sont alors envoyées sous forme de chaîne de caractères ; y compris les nombres comme par exemple les coordonnées de la balle. Bien sûr, on s'assure donc de faire du transtypage côté client et côté serveur pour manipuler les bons types.

\end{document}
